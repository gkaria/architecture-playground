{
  "calm_version": "1.0",
  "metadata": {
    "title": "Task Manager - Monolithic Architecture",
    "description": "A monolithic implementation of a Task Manager application",
    "author": "Architecture Patterns Playground",
    "created": "2025-11-08",
    "version": "1.0.0",
    "architecture_pattern": "monolith"
  },
  "nodes": [
    {
      "unique_id": "monolith-api",
      "node_type": "service",
      "name": "Task Manager API",
      "description": "FastAPI-based monolithic application handling all business logic",
      "interfaces": [
        {
          "unique_id": "rest-api",
          "name": "REST API",
          "protocol": "HTTP/REST",
          "port": 8001,
          "endpoints": [
            {
              "path": "/tasks",
              "method": "POST",
              "description": "Create a new task"
            },
            {
              "path": "/tasks",
              "method": "GET",
              "description": "List all tasks with optional user_id filter"
            },
            {
              "path": "/tasks/{task_id}",
              "method": "GET",
              "description": "Get a specific task"
            },
            {
              "path": "/tasks/{task_id}",
              "method": "PUT",
              "description": "Update a task"
            },
            {
              "path": "/tasks/{task_id}/status",
              "method": "PATCH",
              "description": "Update task status only"
            },
            {
              "path": "/tasks/{task_id}",
              "method": "DELETE",
              "description": "Delete a task"
            }
          ]
        }
      ],
      "capabilities": [
        "task_management",
        "user_management",
        "project_management",
        "data_validation",
        "error_handling",
        "caching"
      ],
      "deployment": {
        "type": "container",
        "technology": "FastAPI",
        "runtime": "Python 3.11+",
        "scaling": "vertical"
      }
    },
    {
      "unique_id": "sqlite-db",
      "node_type": "datastore",
      "name": "SQLite Database",
      "description": "Embedded relational database for all application data",
      "technology": "SQLite",
      "storage_type": "file-based",
      "schemas": [
        {
          "name": "tasks",
          "description": "Stores all task information",
          "fields": [
            "id",
            "title",
            "description",
            "status",
            "priority",
            "user_id",
            "project_id",
            "created_at",
            "updated_at",
            "due_date",
            "tags"
          ]
        },
        {
          "name": "users",
          "description": "Stores user information",
          "fields": [
            "id",
            "username",
            "email",
            "full_name"
          ]
        },
        {
          "name": "projects",
          "description": "Stores project information",
          "fields": [
            "id",
            "name",
            "description",
            "owner_id",
            "members"
          ]
        }
      ]
    },
    {
      "unique_id": "memory-cache",
      "node_type": "cache",
      "name": "In-Memory Cache",
      "description": "Simple in-memory caching layer for frequently accessed data",
      "technology": "Python Dictionary",
      "cache_policy": {
        "ttl_seconds": 60,
        "eviction_policy": "manual_invalidation",
        "scope": "process-local"
      }
    }
  ],
  "relationships": [
    {
      "unique_id": "api-to-db",
      "relationship_type": "connects",
      "source": "monolith-api",
      "destination": "sqlite-db",
      "protocol": "SQLite native",
      "description": "Direct database connection for all data operations",
      "synchronous": true,
      "data_flow": "bidirectional"
    },
    {
      "unique_id": "api-to-cache",
      "relationship_type": "connects",
      "source": "monolith-api",
      "destination": "memory-cache",
      "protocol": "in-process",
      "description": "Cache access for read optimization",
      "synchronous": true,
      "data_flow": "bidirectional"
    }
  ],
  "architecture_characteristics": {
    "scalability": {
      "rating": "low",
      "description": "Vertical scaling only - entire application must be scaled as a unit",
      "limitations": [
        "Cannot scale individual components",
        "Database becomes bottleneck",
        "In-memory cache not distributed"
      ]
    },
    "availability": {
      "rating": "medium",
      "description": "Single point of failure but simple to deploy and monitor",
      "strategies": [
        "Process monitoring and auto-restart",
        "Database backup and restore",
        "Simple health checks"
      ]
    },
    "deployability": {
      "rating": "high",
      "description": "Single deployment unit makes deployment straightforward",
      "deployment_units": 1,
      "deployment_complexity": "low"
    },
    "testability": {
      "rating": "high",
      "description": "All code in one place, easy to test",
      "test_approaches": [
        "Unit tests for business logic",
        "Integration tests with test database",
        "API tests with FastAPI test client"
      ]
    },
    "performance": {
      "rating": "high",
      "description": "No network latency between components",
      "optimizations": [
        "In-memory caching",
        "Direct database access",
        "No serialization overhead"
      ]
    },
    "simplicity": {
      "rating": "high",
      "description": "Straightforward architecture with minimal complexity",
      "benefits": [
        "Easy to understand",
        "Fast development",
        "Simple debugging"
      ]
    },
    "modifiability": {
      "rating": "medium",
      "description": "Changes are localized but tight coupling can make large refactoring difficult",
      "challenges": [
        "Tight coupling between components",
        "Shared database schema",
        "Need to restart entire application for changes"
      ]
    }
  },
  "design_decisions": [
    {
      "id": "ADR-001",
      "title": "Use monolithic architecture for initial implementation",
      "status": "accepted",
      "rationale": "Monolithic architecture provides the simplest starting point for demonstrating core domain logic while minimizing infrastructure complexity"
    },
    {
      "id": "DD-002",
      "title": "SQLite for data persistence",
      "status": "accepted",
      "rationale": "SQLite provides zero-configuration persistence suitable for demonstrations and learning, with easy upgrade path to PostgreSQL if needed"
    },
    {
      "id": "DD-003",
      "title": "In-memory caching strategy",
      "status": "accepted",
      "rationale": "Simple dictionary-based caching demonstrates caching concepts without external dependencies, suitable for single-instance deployment"
    },
    {
      "id": "DD-004",
      "title": "FastAPI framework",
      "status": "accepted",
      "rationale": "FastAPI provides modern Python API development with automatic OpenAPI documentation, type safety, and excellent performance"
    }
  ],
  "quality_attributes": {
    "maintainability": "Code is well-organized with clear separation between database, business logic, and API layers within the monolith",
    "security": "Basic validation through Pydantic models, no authentication implemented (educational purposes)",
    "observability": "Standard FastAPI logging and automatic OpenAPI documentation",
    "cost": "Minimal infrastructure cost - can run on free tier hosting"
  },
  "constraints": [
    "Single-threaded SQLite limits concurrent write operations",
    "In-memory cache is not shared across instances",
    "No built-in authentication or authorization",
    "Vertical scaling only"
  ],
  "assumptions": [
    "Low to moderate traffic volume",
    "Single instance deployment sufficient",
    "Educational/demonstration purposes",
    "Data can fit in single database file"
  ],
  "evolution_path": {
    "current_state": "monolith",
    "next_steps": [
      "Modular Monolith - Add clear module boundaries",
      "Add distributed caching (Redis)",
      "Migrate to PostgreSQL for better concurrency",
      "Extract services for microservices pattern"
    ]
  }
}
